{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JWKNZ Docs In my GitHub Account and this Github Account I have bunch of howto repositories. I might do something more with them one day, but for now they are just code examples. This site serves to provide some documentation for them. I have broken them into the sections based on frameworks. DOTNET CORE SQLSVR WEB API","title":"Home"},{"location":"#jwknz-docs","text":"In my GitHub Account and this Github Account I have bunch of howto repositories. I might do something more with them one day, but for now they are just code examples. This site serves to provide some documentation for them. I have broken them into the sections based on frameworks.","title":"JWKNZ Docs"},{"location":"#dotnet-core","text":"SQLSVR WEB API","title":"DOTNET CORE"},{"location":"dotnet_core/","text":"Dotnet Core SQLSVR WEB API","title":"Dotnet Core"},{"location":"dotnet_core/#dotnet-core","text":"SQLSVR WEB API","title":"Dotnet Core"},{"location":"dotnet_core/SQLSVR_WEBAPI/","text":"SQLSVR_WEBAPI This project builds a webapi that is linked to a MSSQL server. It includes the full CRUD operations for the Player table, but the other are empty as part of an exercise. The version for dotnet 2.1.x is here","title":"SQLSVR_WEBAPI"},{"location":"dotnet_core/SQLSVR_WEBAPI/#sqlsvr_webapi","text":"This project builds a webapi that is linked to a MSSQL server. It includes the full CRUD operations for the Player table, but the other are empty as part of an exercise. The version for dotnet 2.1.x is here","title":"SQLSVR_WEBAPI"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/","text":"Introduction In this project, we are going to look at how to build a webapi that connects to a MSSQL database. The idea (and use case) for this api is to be able to connect any (1 or more) application(s) to a database on a remote or local server without having to store any sensitive information within the application itself. The credentails for the databse will be loaded using environment variables and the system is setup using docker containers, so it is easily deployable. So let's get started! Attention For this tutorial I assume you have the following installed: VSCODE Docker (docker-toolbox or docker for your operating system) You will need to adjust your docker setup or Virtual Box docker VM to support 2GB of RAM to support the MSSQL Server Git (which will give you git bash on Windows) Create a new project Not all of these steps are required, but they are useful and they will help you build a good API (and coding habits) - so treat them as if they are all required. Note When it says \"Type in\" it means type in the terminal The projectname is a placeholder - type in your own name, but do not type in the angle brackets Type in git init projectname to create a working directory with a git repository Go into the folder by typing in cd projectname Type in dotnet --list-sdks to check what versions of dotnet core you have installed on your machine. This is required to see if you need to install the version that this tutorial requires. You should see something like this: Output of dotnet --list-sdks $ dotnet --list-sdks 2.1.505 [/usr/local/share/dotnet/sdk] 2.2.104 [/usr/local/share/dotnet/sdk] 3.0.100-preview-010184 [/usr/local/share/dotnet/sdk] 3.0.100-preview3-010431 [/usr/local/share/dotnet/sdk] Tip You can find all of the dotnet core sdks here But for this tutorial we are working with this version. For this tutorial we are going to focus on version 2.1.x Next type in dotnet new global to create a global.json file that you can use to specify what version of dotnet core you will use for the project. You will need to open this file in a code editor and change the version number to the version you have on your machine - I have 2.1.5 global.json { sdk : { version : 2.1.505 } } Save and close the file. Now you need to create your project, if you create it before the global.json change, you will create a project with the newest version and some of the instructions below may not work. To create your project type in dotnet new webapi to create a new webapi project Next you will need to create a .gitignore file since we don't want to push all our binary and non essential files into our repository. Open the the .gitignore file from the official dotnet core repository and paste it into your .gitignore file. Back in the terminal start your project by typing in dotnet run and view your site by going to http://localhost:5000/api/values If you see the a json string with: Output of default api [ value1 , value2 ] Then you have a working api project and we can start making the changes we need to connect it to a database. Hint Do an initial commit to your repository type in: git add . followed by git commit -m \"Initial Commit\" Making regular commits allows you to revert back to previous version of your code if you make an error. Setting up the database At the moment we have installed the dotnet sdk on our machine and this is the easiest since we can just run the dotnet commands from our terminal. However to run a MSSQL Server you will either need to go through a tedious installation process, if you are on a Windows machine or else you are out of luck. That is until Microsoft embraced the world of containers and allows us to install it as part of a docker container. So in your terminal (or docker-toolbox for windows git bash terminal) type the following in to download the 2017 version of MSSQL Server docker pull mcr.microsoft.com/mssql/server:2017-latest-ubuntu After the download is complete type in: docker run -e ACCEPT_EULA=Y -e SA_PASSWORD=yourStrong(*)Password -e MSSQL_PID=Express -p 1433:1433 -d mcr.microsoft.com/mssql/server:2017-latest-ubuntu The password is set to yourStrong(*)Password which is the default password with the ! changed into an * - needless to say, you should probably change this, but it would be bad if I document my passwords here :-) Once that you have run that command, you mssql server is up and running, so let's leave that sitting there for the moment. Success If all of the stuff above went well, you now have your development environment setup. We will talk about setting up the production side of things later, but let's write some code ... Populating our Database with some data We now need to open our project in our code editor, so type in: # if you are already in your project folder code . # if you are in its parent folder code projectname This will open the project in Visual Studio Code. Create a folder called sql and add 2 files to that folder, call the files tables.sql and data.sql respectively. You can view a set of SQL files in the code repository the table structure can be found here and the data for part of the database can be found here Copy the contents of the files into your project files. Next we need to install an extension so we can execute code, since vscode detected that you are creating sql files, it may have already prompted you to install it. Since we are working with MSSQL it will be the right extension. (Do not install this extension if you are working with MySQL) In any case, if you missed the prompt or it didn't happen, you can type this in the terminal to install it. code --install-extension ms-mssql.mssql After the install is complete, you will need to connect vscode to your data base, which you can do like this: vscode-setup-mssql-database-connection.mov Note If you are using docker toolbox, then your docker containers are inside of a Virtualbox VM. Instead of typing in localhost, you will need to type in the VM's ip address, which is: 192.168.99.100 Once you have the connection setup, go to the sql files and right click and select Execute Query Do this for the tables.sql first and then the data.sql You should see the results of the queries pop up in the side pane on the right, which you can close afterwards. Warning The above steps assume your database is still running in the docker container. So if you have any errors, check that first by typing in docker ps -a into the terminal SETUP EF Core (Entity Framework) Entity Framework is part of the dotnet family and allows for super easy integration of a database to an application, may it be web based or otherwise. There are 2 approaches you can take: 1) Code First or 2) Data First. Since we already have a database, let's look at the Data First option. Copy the ItemGroup tag below and paste it in the .csproj file of your project. Note These packages are aligned to work with dotnet core 2.1.x, so these will need to be updated if you are using a newer version. ItemGroup PackageReference Include= Microsoft.AspNetCore.App / PackageReference Include= Microsoft.AspNetCore.Razor.Design Version= 2.1.2 PrivateAssets= All / PackageReference Include= Microsoft.EntityFrameworkCore Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer.Design Version= 1.1.6 / PackageReference Include= Microsoft.EntityFrameworkCore.Tools Version= 2.1.1 IncludeAssets runtime; build; native; contentfiles; analyzers /IncludeAssets PrivateAssets all /PrivateAssets /PackageReference /ItemGroup Type in dotnet restore to install the nuget packages. Create a folder called Models and then run this command to have it create all the models for you. Note You will need to change the credentials to suit your setup. The DB Context is related to the sql files above, this would obviously be different if you are working on your own project. dotnet ef dbcontext scaffold Server=localhost; Database=Rugby7db; User=sa; Password=yourStrong(*)Password; Microsoft.EntityFrameworkCore.SqlServer -o Models -f -c Rugby7Context In your startup.cs file, add this as your connection string Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; In the ConfigureServices under the services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1); line paste this: // Connect to DB string connection = ConnectionString : Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; ; services.AddDbContext Rugby7Context (options = options .UseSqlServer(connection) ); Success So now that the database and models are setup, we are able to get to coding the API. We will look at setting up the api controllers in the next section","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#introduction","text":"In this project, we are going to look at how to build a webapi that connects to a MSSQL database. The idea (and use case) for this api is to be able to connect any (1 or more) application(s) to a database on a remote or local server without having to store any sensitive information within the application itself. The credentails for the databse will be loaded using environment variables and the system is setup using docker containers, so it is easily deployable. So let's get started! Attention For this tutorial I assume you have the following installed: VSCODE Docker (docker-toolbox or docker for your operating system) You will need to adjust your docker setup or Virtual Box docker VM to support 2GB of RAM to support the MSSQL Server Git (which will give you git bash on Windows)","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#create-a-new-project","text":"Not all of these steps are required, but they are useful and they will help you build a good API (and coding habits) - so treat them as if they are all required. Note When it says \"Type in\" it means type in the terminal The projectname is a placeholder - type in your own name, but do not type in the angle brackets Type in git init projectname to create a working directory with a git repository Go into the folder by typing in cd projectname Type in dotnet --list-sdks to check what versions of dotnet core you have installed on your machine. This is required to see if you need to install the version that this tutorial requires. You should see something like this: Output of dotnet --list-sdks $ dotnet --list-sdks 2.1.505 [/usr/local/share/dotnet/sdk] 2.2.104 [/usr/local/share/dotnet/sdk] 3.0.100-preview-010184 [/usr/local/share/dotnet/sdk] 3.0.100-preview3-010431 [/usr/local/share/dotnet/sdk] Tip You can find all of the dotnet core sdks here But for this tutorial we are working with this version. For this tutorial we are going to focus on version 2.1.x Next type in dotnet new global to create a global.json file that you can use to specify what version of dotnet core you will use for the project. You will need to open this file in a code editor and change the version number to the version you have on your machine - I have 2.1.5 global.json { sdk : { version : 2.1.505 } } Save and close the file. Now you need to create your project, if you create it before the global.json change, you will create a project with the newest version and some of the instructions below may not work. To create your project type in dotnet new webapi to create a new webapi project Next you will need to create a .gitignore file since we don't want to push all our binary and non essential files into our repository. Open the the .gitignore file from the official dotnet core repository and paste it into your .gitignore file. Back in the terminal start your project by typing in dotnet run and view your site by going to http://localhost:5000/api/values If you see the a json string with: Output of default api [ value1 , value2 ] Then you have a working api project and we can start making the changes we need to connect it to a database. Hint Do an initial commit to your repository type in: git add . followed by git commit -m \"Initial Commit\" Making regular commits allows you to revert back to previous version of your code if you make an error.","title":"Create a new project"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#setting-up-the-database","text":"At the moment we have installed the dotnet sdk on our machine and this is the easiest since we can just run the dotnet commands from our terminal. However to run a MSSQL Server you will either need to go through a tedious installation process, if you are on a Windows machine or else you are out of luck. That is until Microsoft embraced the world of containers and allows us to install it as part of a docker container. So in your terminal (or docker-toolbox for windows git bash terminal) type the following in to download the 2017 version of MSSQL Server docker pull mcr.microsoft.com/mssql/server:2017-latest-ubuntu After the download is complete type in: docker run -e ACCEPT_EULA=Y -e SA_PASSWORD=yourStrong(*)Password -e MSSQL_PID=Express -p 1433:1433 -d mcr.microsoft.com/mssql/server:2017-latest-ubuntu The password is set to yourStrong(*)Password which is the default password with the ! changed into an * - needless to say, you should probably change this, but it would be bad if I document my passwords here :-) Once that you have run that command, you mssql server is up and running, so let's leave that sitting there for the moment. Success If all of the stuff above went well, you now have your development environment setup. We will talk about setting up the production side of things later, but let's write some code ...","title":"Setting up the database"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#populating-our-database-with-some-data","text":"We now need to open our project in our code editor, so type in: # if you are already in your project folder code . # if you are in its parent folder code projectname This will open the project in Visual Studio Code. Create a folder called sql and add 2 files to that folder, call the files tables.sql and data.sql respectively. You can view a set of SQL files in the code repository the table structure can be found here and the data for part of the database can be found here Copy the contents of the files into your project files. Next we need to install an extension so we can execute code, since vscode detected that you are creating sql files, it may have already prompted you to install it. Since we are working with MSSQL it will be the right extension. (Do not install this extension if you are working with MySQL) In any case, if you missed the prompt or it didn't happen, you can type this in the terminal to install it. code --install-extension ms-mssql.mssql After the install is complete, you will need to connect vscode to your data base, which you can do like this: vscode-setup-mssql-database-connection.mov Note If you are using docker toolbox, then your docker containers are inside of a Virtualbox VM. Instead of typing in localhost, you will need to type in the VM's ip address, which is: 192.168.99.100 Once you have the connection setup, go to the sql files and right click and select Execute Query Do this for the tables.sql first and then the data.sql You should see the results of the queries pop up in the side pane on the right, which you can close afterwards. Warning The above steps assume your database is still running in the docker container. So if you have any errors, check that first by typing in docker ps -a into the terminal","title":"Populating our Database with some data"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#setup-ef-core-entity-framework","text":"Entity Framework is part of the dotnet family and allows for super easy integration of a database to an application, may it be web based or otherwise. There are 2 approaches you can take: 1) Code First or 2) Data First. Since we already have a database, let's look at the Data First option. Copy the ItemGroup tag below and paste it in the .csproj file of your project. Note These packages are aligned to work with dotnet core 2.1.x, so these will need to be updated if you are using a newer version. ItemGroup PackageReference Include= Microsoft.AspNetCore.App / PackageReference Include= Microsoft.AspNetCore.Razor.Design Version= 2.1.2 PrivateAssets= All / PackageReference Include= Microsoft.EntityFrameworkCore Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer.Design Version= 1.1.6 / PackageReference Include= Microsoft.EntityFrameworkCore.Tools Version= 2.1.1 IncludeAssets runtime; build; native; contentfiles; analyzers /IncludeAssets PrivateAssets all /PrivateAssets /PackageReference /ItemGroup Type in dotnet restore to install the nuget packages. Create a folder called Models and then run this command to have it create all the models for you. Note You will need to change the credentials to suit your setup. The DB Context is related to the sql files above, this would obviously be different if you are working on your own project. dotnet ef dbcontext scaffold Server=localhost; Database=Rugby7db; User=sa; Password=yourStrong(*)Password; Microsoft.EntityFrameworkCore.SqlServer -o Models -f -c Rugby7Context In your startup.cs file, add this as your connection string Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; In the ConfigureServices under the services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1); line paste this: // Connect to DB string connection = ConnectionString : Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; ; services.AddDbContext Rugby7Context (options = options .UseSqlServer(connection) ); Success So now that the database and models are setup, we are able to get to coding the API. We will look at setting up the api controllers in the next section","title":"SETUP EF Core (Entity Framework)"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/","text":"Introduction In this part we are going to look at creating a CRUD api that is connected MSSQL. This part will dive right into creating the api controller. So if you need to setup the project,read part 1 first. The Models When looking at creating an API, the design pattern closely follows the one of an MVC paradigm - but it doesn't include the V (View). We still have controllers and we still need models we created these in part 1. The main part to point out is that Models are normal POCO (plain old class objects) files, but only include properties - there are no methods, fields, constructors etc. of any kind in these files. DBContext When creating your models using Entity Framework you also create a DBContext, in this demo we created one called Rugby7Context. In this file we have a method that creates our models, it reads the structure of our SQL tables and then using a ModelBuilder it creates our model classes, which contain all of our column names and their properties. Warning If you need to make a change to your table, you can do so, but you also need to rerun the ef scafholding command. These would be the steps to take: Make changes to your SQL file Recreate the table structure Run the EF Scafholding command (in part 1) The Controller The Controllers are the beasts in the api, they can be big complex files depending on the table structure you have in your database. Let's break down a few basics: The Controller Name Each Controller matches a single model - no more no less. Each Model is linked to a single table in the SQL database - no more no less. Each Controller inherites from the ControllerBase class, where the different Route routes are defined. To make sure that each Controller knows it is specific for a web api, we need to add some attributes to the class and its methods. Just above the class we need these 2 attrinbutes API Attribute Definition [ApiController] This indicates that we are creating an API [Route(\"api/[controller]\")] Sits above the ApiController and defines the route we need to view our data Inside the class above each of the routing methods, we need to place these. API Attribute Definition [HttpGet] Used for a Get method, returns all the data in the api for this controller [HttpGet](\"{id}\") Same as an HttpGet attribute, but only returns the data for a specific id, which corrolates to a row of the table in the database. [HttpPost] Add data to our database, this takes an instance of the model as a parameter. [HttpPut(\"{id}\")] Update an existing item in the database, this takes 2 parameters - 1 for the id that needs to be updated and 2 an instance of the model to process the properties. [HttpDelete(\"{id}\")] Removes the item with the selected id, so that will need to be passed in as the parameter to the method. Next up we need instantiate the model context that matches the controller: Setting up the context private readonly Rugby7Context _context ; public PlayersController ( Rugby7Context context ) { _context = context ; } In the code above, the Context and Controller are matching the code given with the sql file - again if you are using different data then your project then you will need to change that. The only other thing that the controller contains are the routing methods - anything not related to the routing is not included in this class. Any helper methods should be included in a seperate class to keep things clean. The HttpGet Method Demo Code [HttpGet] public async Task ActionResult IEnumerable Players GetPlayers () { return await _context . Players . ToListAsync (); } The HttpGet is the simplest of all, you define that you want a method that returns IEnumerable ModelName and call it give it a meaningful name like: GetPlayers() You then just return the context with the model class convert it to a List The Single ID HttpGet Method Demo Code [HttpGet( {id} )] public async Task ActionResult Players GetPlayer ( long id ) { Players item = await _context . Players . FindAsync ( id ); if ( item == null ) { return NotFound (); } return item ; } First we need to see if the id is in the database and if it isn't we need to return that message to the api user. If it does exist then return that object to the api user. Since we are only returning a single instance, we don't need to return it as a list. HttpPost Method Demo Code [HttpPost] public async Task ActionResult Players PostPlayer ( Players item ) { _context . Players . Add ( item ); await _context . SaveChangesAsync (); return CreatedAtAction ( nameof ( GetPlayers ), item ); } We can only ever add a single object to the database The item gets added and is saved to the databse The object details are returned to the api user HttpPut Method Demo Code [HttpPut( {id} )] public async Task IActionResult PutTodoItem ( short id , Players item ) { if ( id != item . PlayerId ) { return BadRequest (); } _context . Entry ( item ). State = EntityState . Modified ; await _context . SaveChangesAsync (); return Content ( Player has been updated ); } First we check if the id argument exists in the database and if it doesn't the request is cancelled. If the id does exists the EntitySate uses the Modified property to flag any changes The data is then updated and saved We return a message to the API user Warning There are a couple of things to watch out for when updating data: If your SQL code does not have an id columnn called id, then you will need to pass in the id property in your data You will need to pass in the id you want to update in the URL, otherwise it will update all of the data that HttpDelete Method Demo Code public async Task IActionResult DeleteTodoItem ( short id ) { Players player = await _context . Players . FindAsync ( id ); if ( player == null ) { return NotFound (); } _context . Players . Remove ( player ); await _context . SaveChangesAsync (); return Content ( Player has been removed ); } The first part is the same as what you have seen in the HttpGet(\"{id}\") method. If the record is found, it is removed The api user gets a message General Notes: So that is all you need to do to create a simple api and because we use the entity framework, the context does all the heavy lifting for you. Even so - there a couple of things to note: the Get Methods, return data from the database, this will be in JSON format by default. the Post, Put and Delete method don't return anything by default, but you still need to inform the api user. For this we can use the Content() that takes string. It would be nice to return a string that is formatted in JSON format, so use something like \"{msg: user has been updated}\"","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#introduction","text":"In this part we are going to look at creating a CRUD api that is connected MSSQL. This part will dive right into creating the api controller. So if you need to setup the project,read part 1 first.","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the-models","text":"When looking at creating an API, the design pattern closely follows the one of an MVC paradigm - but it doesn't include the V (View). We still have controllers and we still need models we created these in part 1. The main part to point out is that Models are normal POCO (plain old class objects) files, but only include properties - there are no methods, fields, constructors etc. of any kind in these files.","title":"The Models"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#dbcontext","text":"When creating your models using Entity Framework you also create a DBContext, in this demo we created one called Rugby7Context. In this file we have a method that creates our models, it reads the structure of our SQL tables and then using a ModelBuilder it creates our model classes, which contain all of our column names and their properties. Warning If you need to make a change to your table, you can do so, but you also need to rerun the ef scafholding command. These would be the steps to take: Make changes to your SQL file Recreate the table structure Run the EF Scafholding command (in part 1)","title":"DBContext"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the-controller","text":"The Controllers are the beasts in the api, they can be big complex files depending on the table structure you have in your database. Let's break down a few basics:","title":"The Controller"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the-controller-name","text":"Each Controller matches a single model - no more no less. Each Model is linked to a single table in the SQL database - no more no less. Each Controller inherites from the ControllerBase class, where the different Route routes are defined. To make sure that each Controller knows it is specific for a web api, we need to add some attributes to the class and its methods. Just above the class we need these 2 attrinbutes API Attribute Definition [ApiController] This indicates that we are creating an API [Route(\"api/[controller]\")] Sits above the ApiController and defines the route we need to view our data Inside the class above each of the routing methods, we need to place these. API Attribute Definition [HttpGet] Used for a Get method, returns all the data in the api for this controller [HttpGet](\"{id}\") Same as an HttpGet attribute, but only returns the data for a specific id, which corrolates to a row of the table in the database. [HttpPost] Add data to our database, this takes an instance of the model as a parameter. [HttpPut(\"{id}\")] Update an existing item in the database, this takes 2 parameters - 1 for the id that needs to be updated and 2 an instance of the model to process the properties. [HttpDelete(\"{id}\")] Removes the item with the selected id, so that will need to be passed in as the parameter to the method. Next up we need instantiate the model context that matches the controller: Setting up the context private readonly Rugby7Context _context ; public PlayersController ( Rugby7Context context ) { _context = context ; } In the code above, the Context and Controller are matching the code given with the sql file - again if you are using different data then your project then you will need to change that. The only other thing that the controller contains are the routing methods - anything not related to the routing is not included in this class. Any helper methods should be included in a seperate class to keep things clean.","title":"The Controller Name"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the-httpget-method","text":"Demo Code [HttpGet] public async Task ActionResult IEnumerable Players GetPlayers () { return await _context . Players . ToListAsync (); } The HttpGet is the simplest of all, you define that you want a method that returns IEnumerable ModelName and call it give it a meaningful name like: GetPlayers() You then just return the context with the model class convert it to a List","title":"The HttpGet Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the-single-id-httpget-method","text":"Demo Code [HttpGet( {id} )] public async Task ActionResult Players GetPlayer ( long id ) { Players item = await _context . Players . FindAsync ( id ); if ( item == null ) { return NotFound (); } return item ; } First we need to see if the id is in the database and if it isn't we need to return that message to the api user. If it does exist then return that object to the api user. Since we are only returning a single instance, we don't need to return it as a list.","title":"The Single ID HttpGet Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#httppost-method","text":"Demo Code [HttpPost] public async Task ActionResult Players PostPlayer ( Players item ) { _context . Players . Add ( item ); await _context . SaveChangesAsync (); return CreatedAtAction ( nameof ( GetPlayers ), item ); } We can only ever add a single object to the database The item gets added and is saved to the databse The object details are returned to the api user","title":"HttpPost Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#httpput-method","text":"Demo Code [HttpPut( {id} )] public async Task IActionResult PutTodoItem ( short id , Players item ) { if ( id != item . PlayerId ) { return BadRequest (); } _context . Entry ( item ). State = EntityState . Modified ; await _context . SaveChangesAsync (); return Content ( Player has been updated ); } First we check if the id argument exists in the database and if it doesn't the request is cancelled. If the id does exists the EntitySate uses the Modified property to flag any changes The data is then updated and saved We return a message to the API user Warning There are a couple of things to watch out for when updating data: If your SQL code does not have an id columnn called id, then you will need to pass in the id property in your data You will need to pass in the id you want to update in the URL, otherwise it will update all of the data that","title":"HttpPut Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#httpdelete-method","text":"Demo Code public async Task IActionResult DeleteTodoItem ( short id ) { Players player = await _context . Players . FindAsync ( id ); if ( player == null ) { return NotFound (); } _context . Players . Remove ( player ); await _context . SaveChangesAsync (); return Content ( Player has been removed ); } The first part is the same as what you have seen in the HttpGet(\"{id}\") method. If the record is found, it is removed The api user gets a message","title":"HttpDelete Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#general-notes","text":"So that is all you need to do to create a simple api and because we use the entity framework, the context does all the heavy lifting for you. Even so - there a couple of things to note: the Get Methods, return data from the database, this will be in JSON format by default. the Post, Put and Delete method don't return anything by default, but you still need to inform the api user. For this we can use the Content() that takes string. It would be nice to return a string that is formatted in JSON format, so use something like \"{msg: user has been updated}\"","title":"General Notes:"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/03-exercises/","text":"Exercises Exercise 1 The api is not complete, in the demo we looked at the player API, but we still have models for the following tables: GameSchedule PoolPoints Staff Teams Your task is to complete the api so data can be submitted using PostMan.","title":"Exercises"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/03-exercises/#exercises","text":"","title":"Exercises"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/03-exercises/#exercise-1","text":"The api is not complete, in the demo we looked at the player API, but we still have models for the following tables: GameSchedule PoolPoints Staff Teams Your task is to complete the api so data can be submitted using PostMan.","title":"Exercise 1"},{"location":"php/container_setup/install/","text":"Setup new container important Stop any current containers you have going this will free up the ports that are in use: docker stop $( docker ps -a ) This won't delete them, but it will free up the ports that are used by any containers. Navigate to your code folder where you want to store you project, this could be your desktop or a designated folder. cd ~/Desktop Set a ENV Variable temporary for the folder name FOLDER= VALUE where = the name you want your project to be Note ENV Variables, will loose their value when you close the terminal window. There is a way to recreate them, but since we don't want to have this variable permanently setup we won't do that here. Every time you want to reference our project, we can just use $FOLDER instead of the actual name. Download the docker-compose file curl -LOk https://github.com/to-jk11/php-container-kit/archive/master.zip unzip master.zip rm -f master.zip mv php-container-kit-master $FOLDER mkdir -p $FOLDER /www Go into the VALUE folder: cd $FOLDER Inside the folder there is a docker-compose.yml file. Run the docker-compose command to get your containers up and running: docker-compose up -d The www folder serves as the root folder of your website. So that is where you put your code files. You can now open the www in your favourite code editor. (for example code www ) Note The container has been setup with the apache2 rewrite module enabled. This will be important when we start using MVC.","title":"Setup new container"},{"location":"php/container_setup/install/#setup-new-container","text":"important Stop any current containers you have going this will free up the ports that are in use: docker stop $( docker ps -a ) This won't delete them, but it will free up the ports that are used by any containers. Navigate to your code folder where you want to store you project, this could be your desktop or a designated folder. cd ~/Desktop Set a ENV Variable temporary for the folder name FOLDER= VALUE where = the name you want your project to be Note ENV Variables, will loose their value when you close the terminal window. There is a way to recreate them, but since we don't want to have this variable permanently setup we won't do that here. Every time you want to reference our project, we can just use $FOLDER instead of the actual name. Download the docker-compose file curl -LOk https://github.com/to-jk11/php-container-kit/archive/master.zip unzip master.zip rm -f master.zip mv php-container-kit-master $FOLDER mkdir -p $FOLDER /www Go into the VALUE folder: cd $FOLDER Inside the folder there is a docker-compose.yml file. Run the docker-compose command to get your containers up and running: docker-compose up -d The www folder serves as the root folder of your website. So that is where you put your code files. You can now open the www in your favourite code editor. (for example code www ) Note The container has been setup with the apache2 rewrite module enabled. This will be important when we start using MVC.","title":"Setup new container"},{"location":"php/mvc_framework/setup/","text":"Setup MVC Project What you need This repository should be loaded in the www folder if you are using the https://github.com/to-jk11/php-container-kit/ repository Download the following files into the www container Get the MVC Framework curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip unzip master.zip cd php-mvc-kit-master/ find . -maxdepth 1 -exec mv {} .. \\; cd .. rm -rf php-mvc-kit-master rm -rf master.zip A lot happens in the command above, so if you want to know what it does, click on the hint below. If you want to know what happens First we download the repostory that contains all the base code as a zip file curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip Next we unzip the master.zip file, which gives us the php-mvc-kit-master folder cd php-mvc-kit-master Then we move all of the files into the parent folder: `find . -maxdepth 1 -exec mv {} .. \\;` Ignore the message that says: mv: cannot move .' to ../.': Device or resource busy Last we go back to the parent folder and remove the php-mvc-kit-master folder and the master.zip file cd .. rm -rf php-mvc-kit-master rm -rf master.zip Setup your git repository Setup Git Next you will need to create your git repository so you can save your work: git init Add the remote repository link // If you are using https and have a public repository (uses port 443) git remote add origin https://url-to-your-repo // If you are using https and have a private repository (uses port 443) git remote add origin https://token@username:url-to-your-repo // If you are using ssh (uses port 22) git remote add origin git@github.com:username/reponame The link \"https://url-to-your-repo\" is the link to your github repository Now you can go to http://localhost:8000 (docker for (your OS)) or http://192.168.99.100:8000 (docker toolbox in combination with VirtualBox) and you will see the following message: Note you will now need to load your sql files to see the website working properly","title":"Setup MVC Project"},{"location":"php/mvc_framework/setup/#setup-mvc-project","text":"What you need This repository should be loaded in the www folder if you are using the https://github.com/to-jk11/php-container-kit/ repository Download the following files into the www container Get the MVC Framework curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip unzip master.zip cd php-mvc-kit-master/ find . -maxdepth 1 -exec mv {} .. \\; cd .. rm -rf php-mvc-kit-master rm -rf master.zip A lot happens in the command above, so if you want to know what it does, click on the hint below. If you want to know what happens First we download the repostory that contains all the base code as a zip file curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip Next we unzip the master.zip file, which gives us the php-mvc-kit-master folder cd php-mvc-kit-master Then we move all of the files into the parent folder: `find . -maxdepth 1 -exec mv {} .. \\;` Ignore the message that says: mv: cannot move .' to ../.': Device or resource busy Last we go back to the parent folder and remove the php-mvc-kit-master folder and the master.zip file cd .. rm -rf php-mvc-kit-master rm -rf master.zip","title":"Setup MVC Project"},{"location":"php/mvc_framework/setup/#setup-your-git-repository","text":"Setup Git Next you will need to create your git repository so you can save your work: git init Add the remote repository link // If you are using https and have a public repository (uses port 443) git remote add origin https://url-to-your-repo // If you are using https and have a private repository (uses port 443) git remote add origin https://token@username:url-to-your-repo // If you are using ssh (uses port 22) git remote add origin git@github.com:username/reponame The link \"https://url-to-your-repo\" is the link to your github repository Now you can go to http://localhost:8000 (docker for (your OS)) or http://192.168.99.100:8000 (docker toolbox in combination with VirtualBox) and you will see the following message: Note you will now need to load your sql files to see the website working properly","title":"Setup your git repository"}]}