{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JWKNZ Docs In my GitHub Account and this Github Account I have bunch of howto repositories. I might do something more with them one day, but for now they are just code examples. This site serves to provide some documentation for them. To navigate your way through the different tutorials, follow the naviagtion in the left menu. Content All tutorials are written by me and are free for you to learn from. If I use some specific information from a site or person - I will credit them.","title":"Home"},{"location":"#jwknz_docs","text":"In my GitHub Account and this Github Account I have bunch of howto repositories. I might do something more with them one day, but for now they are just code examples. This site serves to provide some documentation for them. To navigate your way through the different tutorials, follow the naviagtion in the left menu. Content All tutorials are written by me and are free for you to learn from. If I use some specific information from a site or person - I will credit them.","title":"JWKNZ Docs"},{"location":"dotnet_core/","text":"Dotnet Core SQLSVR WEB API","title":"Dotnet Core"},{"location":"dotnet_core/#dotnet_core","text":"SQLSVR WEB API","title":"Dotnet Core"},{"location":"dotnet_core/SQLSVR_WEBAPI/","text":"SQLSVR_WEBAPI This project builds a webapi that is linked to a MSSQL server. It includes the full CRUD operations for the Player table, but the other are empty as part of an exercise. The version for dotnet 2.1.x is here","title":"SQLSVR_WEBAPI"},{"location":"dotnet_core/SQLSVR_WEBAPI/#sqlsvr_webapi","text":"This project builds a webapi that is linked to a MSSQL server. It includes the full CRUD operations for the Player table, but the other are empty as part of an exercise. The version for dotnet 2.1.x is here","title":"SQLSVR_WEBAPI"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/","text":"Introduction In this project, we are going to look at how to build a webapi that connects to a MSSQL database. The idea (and use case) for this api is to be able to connect any (1 or more) application(s) to a database on a remote or local server without having to store any sensitive information within the application itself. The credentails for the databse will be loaded using environment variables and the system is setup using docker containers, so it is easily deployable. So let's get started! Attention For this tutorial I assume you have the following installed: VSCODE Docker (docker-toolbox or docker for your operating system) You will need to adjust your docker setup or Virtual Box docker VM to support 2GB of RAM to support the MSSQL Server Git (which will give you git bash on Windows) Create a new project Not all of these steps are required, but they are useful and they will help you build a good API (and coding habits) - so treat them as if they are all required. Note When it says \"Type in\" it means type in the terminal The projectname is a placeholder - type in your own name, but do not type in the angle brackets Type in git init projectname to create a working directory with a git repository Go into the folder by typing in cd projectname Type in dotnet --list-sdks to check what versions of dotnet core you have installed on your machine. This is required to see if you need to install the version that this tutorial requires. You should see something like this: Output of dotnet --list-sdks $ dotnet --list-sdks 2.1.505 [/usr/local/share/dotnet/sdk] 2.2.104 [/usr/local/share/dotnet/sdk] 3.0.100-preview-010184 [/usr/local/share/dotnet/sdk] 3.0.100-preview3-010431 [/usr/local/share/dotnet/sdk] Tip You can find all of the dotnet core sdks here But for this tutorial we are working with this version. For this tutorial we are going to focus on version 2.1.x Next type in dotnet new global to create a global.json file that you can use to specify what version of dotnet core you will use for the project. You will need to open this file in a code editor and change the version number to the version you have on your machine - I have 2.1.5 global.json { sdk : { version : 2.1.505 } } Save and close the file. Now you need to create your project, if you create it before the global.json change, you will create a project with the newest version and some of the instructions below may not work. To create your project type in dotnet new webapi to create a new webapi project Next you will need to create a .gitignore file since we don't want to push all our binary and non essential files into our repository. Open the the .gitignore file from the official dotnet core repository and paste it into your .gitignore file. Back in the terminal start your project by typing in dotnet run and view your site by going to http://localhost:5000/api/values If you see the a json string with: Output of default api [ value1 , value2 ] Then you have a working api project and we can start making the changes we need to connect it to a database. Hint Do an initial commit to your repository type in: git add . followed by git commit -m \"Initial Commit\" Making regular commits allows you to revert back to previous version of your code if you make an error. Setting up the database At the moment we have installed the dotnet sdk on our machine and this is the easiest since we can just run the dotnet commands from our terminal. However to run a MSSQL Server you will either need to go through a tedious installation process, if you are on a Windows machine or else you are out of luck. That is until Microsoft embraced the world of containers and allows us to install it as part of a docker container. So in your terminal (or docker-toolbox for windows git bash terminal) type the following in to download the 2017 version of MSSQL Server docker pull mcr.microsoft.com/mssql/server:2017-latest-ubuntu After the download is complete type in: docker run -e ACCEPT_EULA=Y -e SA_PASSWORD=yourStrong(*)Password -e MSSQL_PID=Express -p 1433:1433 -d mcr.microsoft.com/mssql/server:2017-latest-ubuntu The password is set to yourStrong(*)Password which is the default password with the ! changed into an * - needless to say, you should probably change this, but it would be bad if I document my passwords here :-) Once that you have run that command, you mssql server is up and running, so let's leave that sitting there for the moment. Success If all of the stuff above went well, you now have your development environment setup. We will talk about setting up the production side of things later, but let's write some code ... Populating our Database with some data We now need to open our project in our code editor, so type in: # if you are already in your project folder code . # if you are in its parent folder code projectname This will open the project in Visual Studio Code. Create a folder called sql and add 2 files to that folder, call the files tables.sql and data.sql respectively. You can view a set of SQL files in the code repository the table structure can be found here and the data for part of the database can be found here Copy the contents of the files into your project files. Next we need to install an extension so we can execute code, since vscode detected that you are creating sql files, it may have already prompted you to install it. Since we are working with MSSQL it will be the right extension. (Do not install this extension if you are working with MySQL) In any case, if you missed the prompt or it didn't happen, you can type this in the terminal to install it. code --install-extension ms-mssql.mssql After the install is complete, you will need to connect vscode to your data base, which you can do like this: vscode-setup-mssql-database-connection.mov Note If you are using docker toolbox, then your docker containers are inside of a Virtualbox VM. Instead of typing in localhost, you will need to type in the VM's ip address, which is: 192.168.99.100 Once you have the connection setup, go to the sql files and right click and select Execute Query Do this for the tables.sql first and then the data.sql You should see the results of the queries pop up in the side pane on the right, which you can close afterwards. Warning The above steps assume your database is still running in the docker container. So if you have any errors, check that first by typing in docker ps -a into the terminal SETUP EF Core (Entity Framework) Entity Framework is part of the dotnet family and allows for super easy integration of a database to an application, may it be web based or otherwise. There are 2 approaches you can take: 1) Code First or 2) Data First. Since we already have a database, let's look at the Data First option. Copy the ItemGroup tag below and paste it in the .csproj file of your project. Note These packages are aligned to work with dotnet core 2.1.x, so these will need to be updated if you are using a newer version. ItemGroup PackageReference Include= Microsoft.AspNetCore.App / PackageReference Include= Microsoft.AspNetCore.Razor.Design Version= 2.1.2 PrivateAssets= All / PackageReference Include= Microsoft.EntityFrameworkCore Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer.Design Version= 1.1.6 / PackageReference Include= Microsoft.EntityFrameworkCore.Tools Version= 2.1.1 IncludeAssets runtime; build; native; contentfiles; analyzers /IncludeAssets PrivateAssets all /PrivateAssets /PackageReference /ItemGroup Type in dotnet restore to install the nuget packages. Create a folder called Models and then run this command to have it create all the models for you. Note You will need to change the credentials to suit your setup. The DB Context is related to the sql files above, this would obviously be different if you are working on your own project. dotnet ef dbcontext scaffold Server=localhost; Database=Rugby7db; User=sa; Password=yourStrong(*)Password; Microsoft.EntityFrameworkCore.SqlServer -o Models -f -c Rugby7Context In your startup.cs file, add this as your connection string Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; In the ConfigureServices under the services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1); line paste this: // Connect to DB string connection = ConnectionString : Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; ; services.AddDbContext Rugby7Context (options = options .UseSqlServer(connection) ); Success So now that the database and models are setup, we are able to get to coding the API. We will look at setting up the api controllers in the next section","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#introduction","text":"In this project, we are going to look at how to build a webapi that connects to a MSSQL database. The idea (and use case) for this api is to be able to connect any (1 or more) application(s) to a database on a remote or local server without having to store any sensitive information within the application itself. The credentails for the databse will be loaded using environment variables and the system is setup using docker containers, so it is easily deployable. So let's get started! Attention For this tutorial I assume you have the following installed: VSCODE Docker (docker-toolbox or docker for your operating system) You will need to adjust your docker setup or Virtual Box docker VM to support 2GB of RAM to support the MSSQL Server Git (which will give you git bash on Windows)","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#create_a_new_project","text":"Not all of these steps are required, but they are useful and they will help you build a good API (and coding habits) - so treat them as if they are all required. Note When it says \"Type in\" it means type in the terminal The projectname is a placeholder - type in your own name, but do not type in the angle brackets Type in git init projectname to create a working directory with a git repository Go into the folder by typing in cd projectname Type in dotnet --list-sdks to check what versions of dotnet core you have installed on your machine. This is required to see if you need to install the version that this tutorial requires. You should see something like this: Output of dotnet --list-sdks $ dotnet --list-sdks 2.1.505 [/usr/local/share/dotnet/sdk] 2.2.104 [/usr/local/share/dotnet/sdk] 3.0.100-preview-010184 [/usr/local/share/dotnet/sdk] 3.0.100-preview3-010431 [/usr/local/share/dotnet/sdk] Tip You can find all of the dotnet core sdks here But for this tutorial we are working with this version. For this tutorial we are going to focus on version 2.1.x Next type in dotnet new global to create a global.json file that you can use to specify what version of dotnet core you will use for the project. You will need to open this file in a code editor and change the version number to the version you have on your machine - I have 2.1.5 global.json { sdk : { version : 2.1.505 } } Save and close the file. Now you need to create your project, if you create it before the global.json change, you will create a project with the newest version and some of the instructions below may not work. To create your project type in dotnet new webapi to create a new webapi project Next you will need to create a .gitignore file since we don't want to push all our binary and non essential files into our repository. Open the the .gitignore file from the official dotnet core repository and paste it into your .gitignore file. Back in the terminal start your project by typing in dotnet run and view your site by going to http://localhost:5000/api/values If you see the a json string with: Output of default api [ value1 , value2 ] Then you have a working api project and we can start making the changes we need to connect it to a database. Hint Do an initial commit to your repository type in: git add . followed by git commit -m \"Initial Commit\" Making regular commits allows you to revert back to previous version of your code if you make an error.","title":"Create a new project"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#setting_up_the_database","text":"At the moment we have installed the dotnet sdk on our machine and this is the easiest since we can just run the dotnet commands from our terminal. However to run a MSSQL Server you will either need to go through a tedious installation process, if you are on a Windows machine or else you are out of luck. That is until Microsoft embraced the world of containers and allows us to install it as part of a docker container. So in your terminal (or docker-toolbox for windows git bash terminal) type the following in to download the 2017 version of MSSQL Server docker pull mcr.microsoft.com/mssql/server:2017-latest-ubuntu After the download is complete type in: docker run -e ACCEPT_EULA=Y -e SA_PASSWORD=yourStrong(*)Password -e MSSQL_PID=Express -p 1433:1433 -d mcr.microsoft.com/mssql/server:2017-latest-ubuntu The password is set to yourStrong(*)Password which is the default password with the ! changed into an * - needless to say, you should probably change this, but it would be bad if I document my passwords here :-) Once that you have run that command, you mssql server is up and running, so let's leave that sitting there for the moment. Success If all of the stuff above went well, you now have your development environment setup. We will talk about setting up the production side of things later, but let's write some code ...","title":"Setting up the database"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#populating_our_database_with_some_data","text":"We now need to open our project in our code editor, so type in: # if you are already in your project folder code . # if you are in its parent folder code projectname This will open the project in Visual Studio Code. Create a folder called sql and add 2 files to that folder, call the files tables.sql and data.sql respectively. You can view a set of SQL files in the code repository the table structure can be found here and the data for part of the database can be found here Copy the contents of the files into your project files. Next we need to install an extension so we can execute code, since vscode detected that you are creating sql files, it may have already prompted you to install it. Since we are working with MSSQL it will be the right extension. (Do not install this extension if you are working with MySQL) In any case, if you missed the prompt or it didn't happen, you can type this in the terminal to install it. code --install-extension ms-mssql.mssql After the install is complete, you will need to connect vscode to your data base, which you can do like this: vscode-setup-mssql-database-connection.mov Note If you are using docker toolbox, then your docker containers are inside of a Virtualbox VM. Instead of typing in localhost, you will need to type in the VM's ip address, which is: 192.168.99.100 Once you have the connection setup, go to the sql files and right click and select Execute Query Do this for the tables.sql first and then the data.sql You should see the results of the queries pop up in the side pane on the right, which you can close afterwards. Warning The above steps assume your database is still running in the docker container. So if you have any errors, check that first by typing in docker ps -a into the terminal","title":"Populating our Database with some data"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/01-project-setup/#setup_ef_core_entity_framework","text":"Entity Framework is part of the dotnet family and allows for super easy integration of a database to an application, may it be web based or otherwise. There are 2 approaches you can take: 1) Code First or 2) Data First. Since we already have a database, let's look at the Data First option. Copy the ItemGroup tag below and paste it in the .csproj file of your project. Note These packages are aligned to work with dotnet core 2.1.x, so these will need to be updated if you are using a newer version. ItemGroup PackageReference Include= Microsoft.AspNetCore.App / PackageReference Include= Microsoft.AspNetCore.Razor.Design Version= 2.1.2 PrivateAssets= All / PackageReference Include= Microsoft.EntityFrameworkCore Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer Version= 2.1.1 / PackageReference Include= Microsoft.EntityFrameworkCore.SqlServer.Design Version= 1.1.6 / PackageReference Include= Microsoft.EntityFrameworkCore.Tools Version= 2.1.1 IncludeAssets runtime; build; native; contentfiles; analyzers /IncludeAssets PrivateAssets all /PrivateAssets /PackageReference /ItemGroup Type in dotnet restore to install the nuget packages. Create a folder called Models and then run this command to have it create all the models for you. Note You will need to change the credentials to suit your setup. The DB Context is related to the sql files above, this would obviously be different if you are working on your own project. dotnet ef dbcontext scaffold Server=localhost; Database=Rugby7db; User=sa; Password=yourStrong(*)Password; Microsoft.EntityFrameworkCore.SqlServer -o Models -f -c Rugby7Context In your startup.cs file, add this as your connection string Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; In the ConfigureServices under the services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1); line paste this: // Connect to DB string connection = ConnectionString : Server=localhost;Database=Rugby7db;User=sa;Password=yourStrong(*)Password; ; services.AddDbContext Rugby7Context (options = options .UseSqlServer(connection) ); Success So now that the database and models are setup, we are able to get to coding the API. We will look at setting up the api controllers in the next section","title":"SETUP EF Core (Entity Framework)"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/","text":"Introduction In this part we are going to look at creating a CRUD api that is connected MSSQL. This part will dive right into creating the api controller. So if you need to setup the project,read part 1 first. The Models When looking at creating an API, the design pattern closely follows the one of an MVC paradigm - but it doesn't include the V (View). We still have controllers and we still need models we created these in part 1. The main part to point out is that Models are normal POCO (plain old class objects) files, but only include properties - there are no methods, fields, constructors etc. of any kind in these files. DBContext When creating your models using Entity Framework you also create a DBContext, in this demo we created one called Rugby7Context. In this file we have a method that creates our models, it reads the structure of our SQL tables and then using a ModelBuilder it creates our model classes, which contain all of our column names and their properties. Warning If you need to make a change to your table, you can do so, but you also need to rerun the ef scafholding command. These would be the steps to take: Make changes to your SQL file Recreate the table structure Run the EF Scafholding command (in part 1) The Controller The Controllers are the beasts in the api, they can be big complex files depending on the table structure you have in your database. Let's break down a few basics: The Controller Name Each Controller matches a single model - no more no less. Each Model is linked to a single table in the SQL database - no more no less. Each Controller inherites from the ControllerBase class, where the different Route routes are defined. To make sure that each Controller knows it is specific for a web api, we need to add some attributes to the class and its methods. Just above the class we need these 2 attrinbutes API Attribute Definition [ApiController] This indicates that we are creating an API [Route(\"api/[controller]\")] Sits above the ApiController and defines the route we need to view our data Inside the class above each of the routing methods, we need to place these. API Attribute Definition [HttpGet] Used for a Get method, returns all the data in the api for this controller [HttpGet](\"{id}\") Same as an HttpGet attribute, but only returns the data for a specific id, which corrolates to a row of the table in the database. [HttpPost] Add data to our database, this takes an instance of the model as a parameter. [HttpPut(\"{id}\")] Update an existing item in the database, this takes 2 parameters - 1 for the id that needs to be updated and 2 an instance of the model to process the properties. [HttpDelete(\"{id}\")] Removes the item with the selected id, so that will need to be passed in as the parameter to the method. Next up we need instantiate the model context that matches the controller: Setting up the context private readonly Rugby7Context _context ; public PlayersController ( Rugby7Context context ) { _context = context ; } In the code above, the Context and Controller are matching the code given with the sql file - again if you are using different data then your project then you will need to change that. The only other thing that the controller contains are the routing methods - anything not related to the routing is not included in this class. Any helper methods should be included in a seperate class to keep things clean. The HttpGet Method Demo Code [HttpGet] public async Task ActionResult IEnumerable Players GetPlayers () { return await _context . Players . ToListAsync (); } The HttpGet is the simplest of all, you define that you want a method that returns IEnumerable ModelName and call it give it a meaningful name like: GetPlayers() You then just return the context with the model class convert it to a List The Single ID HttpGet Method Demo Code [HttpGet( {id} )] public async Task ActionResult Players GetPlayer ( long id ) { Players item = await _context . Players . FindAsync ( id ); if ( item == null ) { return NotFound (); } return item ; } First we need to see if the id is in the database and if it isn't we need to return that message to the api user. If it does exist then return that object to the api user. Since we are only returning a single instance, we don't need to return it as a list. HttpPost Method Demo Code [HttpPost] public async Task ActionResult Players PostPlayer ( Players item ) { _context . Players . Add ( item ); await _context . SaveChangesAsync (); return CreatedAtAction ( nameof ( GetPlayers ), item ); } We can only ever add a single object to the database The item gets added and is saved to the databse The object details are returned to the api user HttpPut Method Demo Code [HttpPut( {id} )] public async Task IActionResult PutTodoItem ( short id , Players item ) { if ( id != item . PlayerId ) { return BadRequest (); } _context . Entry ( item ). State = EntityState . Modified ; await _context . SaveChangesAsync (); return Content ( Player has been updated ); } First we check if the id argument exists in the database and if it doesn't the request is cancelled. If the id does exists the EntitySate uses the Modified property to flag any changes The data is then updated and saved We return a message to the API user Warning There are a couple of things to watch out for when updating data: If your SQL code does not have an id columnn called id, then you will need to pass in the id property in your data You will need to pass in the id you want to update in the URL, otherwise it will update all of the data that HttpDelete Method Demo Code public async Task IActionResult DeleteTodoItem ( short id ) { Players player = await _context . Players . FindAsync ( id ); if ( player == null ) { return NotFound (); } _context . Players . Remove ( player ); await _context . SaveChangesAsync (); return Content ( Player has been removed ); } The first part is the same as what you have seen in the HttpGet(\"{id}\") method. If the record is found, it is removed The api user gets a message General Notes: So that is all you need to do to create a simple api and because we use the entity framework, the context does all the heavy lifting for you. Even so - there a couple of things to note: the Get Methods, return data from the database, this will be in JSON format by default. the Post, Put and Delete method don't return anything by default, but you still need to inform the api user. For this we can use the Content() that takes string. It would be nice to return a string that is formatted in JSON format, so use something like \"{msg: user has been updated}\"","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#introduction","text":"In this part we are going to look at creating a CRUD api that is connected MSSQL. This part will dive right into creating the api controller. So if you need to setup the project,read part 1 first.","title":"Introduction"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the_models","text":"When looking at creating an API, the design pattern closely follows the one of an MVC paradigm - but it doesn't include the V (View). We still have controllers and we still need models we created these in part 1. The main part to point out is that Models are normal POCO (plain old class objects) files, but only include properties - there are no methods, fields, constructors etc. of any kind in these files.","title":"The Models"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#dbcontext","text":"When creating your models using Entity Framework you also create a DBContext, in this demo we created one called Rugby7Context. In this file we have a method that creates our models, it reads the structure of our SQL tables and then using a ModelBuilder it creates our model classes, which contain all of our column names and their properties. Warning If you need to make a change to your table, you can do so, but you also need to rerun the ef scafholding command. These would be the steps to take: Make changes to your SQL file Recreate the table structure Run the EF Scafholding command (in part 1)","title":"DBContext"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the_controller","text":"The Controllers are the beasts in the api, they can be big complex files depending on the table structure you have in your database. Let's break down a few basics:","title":"The Controller"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the_controller_name","text":"Each Controller matches a single model - no more no less. Each Model is linked to a single table in the SQL database - no more no less. Each Controller inherites from the ControllerBase class, where the different Route routes are defined. To make sure that each Controller knows it is specific for a web api, we need to add some attributes to the class and its methods. Just above the class we need these 2 attrinbutes API Attribute Definition [ApiController] This indicates that we are creating an API [Route(\"api/[controller]\")] Sits above the ApiController and defines the route we need to view our data Inside the class above each of the routing methods, we need to place these. API Attribute Definition [HttpGet] Used for a Get method, returns all the data in the api for this controller [HttpGet](\"{id}\") Same as an HttpGet attribute, but only returns the data for a specific id, which corrolates to a row of the table in the database. [HttpPost] Add data to our database, this takes an instance of the model as a parameter. [HttpPut(\"{id}\")] Update an existing item in the database, this takes 2 parameters - 1 for the id that needs to be updated and 2 an instance of the model to process the properties. [HttpDelete(\"{id}\")] Removes the item with the selected id, so that will need to be passed in as the parameter to the method. Next up we need instantiate the model context that matches the controller: Setting up the context private readonly Rugby7Context _context ; public PlayersController ( Rugby7Context context ) { _context = context ; } In the code above, the Context and Controller are matching the code given with the sql file - again if you are using different data then your project then you will need to change that. The only other thing that the controller contains are the routing methods - anything not related to the routing is not included in this class. Any helper methods should be included in a seperate class to keep things clean.","title":"The Controller Name"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the_httpget_method","text":"Demo Code [HttpGet] public async Task ActionResult IEnumerable Players GetPlayers () { return await _context . Players . ToListAsync (); } The HttpGet is the simplest of all, you define that you want a method that returns IEnumerable ModelName and call it give it a meaningful name like: GetPlayers() You then just return the context with the model class convert it to a List","title":"The HttpGet Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#the_single_id_httpget_method","text":"Demo Code [HttpGet( {id} )] public async Task ActionResult Players GetPlayer ( long id ) { Players item = await _context . Players . FindAsync ( id ); if ( item == null ) { return NotFound (); } return item ; } First we need to see if the id is in the database and if it isn't we need to return that message to the api user. If it does exist then return that object to the api user. Since we are only returning a single instance, we don't need to return it as a list.","title":"The Single ID HttpGet Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#httppost_method","text":"Demo Code [HttpPost] public async Task ActionResult Players PostPlayer ( Players item ) { _context . Players . Add ( item ); await _context . SaveChangesAsync (); return CreatedAtAction ( nameof ( GetPlayers ), item ); } We can only ever add a single object to the database The item gets added and is saved to the databse The object details are returned to the api user","title":"HttpPost Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#httpput_method","text":"Demo Code [HttpPut( {id} )] public async Task IActionResult PutTodoItem ( short id , Players item ) { if ( id != item . PlayerId ) { return BadRequest (); } _context . Entry ( item ). State = EntityState . Modified ; await _context . SaveChangesAsync (); return Content ( Player has been updated ); } First we check if the id argument exists in the database and if it doesn't the request is cancelled. If the id does exists the EntitySate uses the Modified property to flag any changes The data is then updated and saved We return a message to the API user Warning There are a couple of things to watch out for when updating data: If your SQL code does not have an id columnn called id, then you will need to pass in the id property in your data You will need to pass in the id you want to update in the URL, otherwise it will update all of the data that","title":"HttpPut Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#httpdelete_method","text":"Demo Code public async Task IActionResult DeleteTodoItem ( short id ) { Players player = await _context . Players . FindAsync ( id ); if ( player == null ) { return NotFound (); } _context . Players . Remove ( player ); await _context . SaveChangesAsync (); return Content ( Player has been removed ); } The first part is the same as what you have seen in the HttpGet(\"{id}\") method. If the record is found, it is removed The api user gets a message","title":"HttpDelete Method"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/02-create-api/#general_notes","text":"So that is all you need to do to create a simple api and because we use the entity framework, the context does all the heavy lifting for you. Even so - there a couple of things to note: the Get Methods, return data from the database, this will be in JSON format by default. the Post, Put and Delete method don't return anything by default, but you still need to inform the api user. For this we can use the Content() that takes string. It would be nice to return a string that is formatted in JSON format, so use something like \"{msg: user has been updated}\"","title":"General Notes:"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/03-exercises/","text":"Exercises Exercise 1 The api is not complete, in the demo we looked at the player API, but we still have models for the following tables: GameSchedule PoolPoints Staff Teams Your task is to complete the api so data can be submitted using PostMan.","title":"Exercises"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/03-exercises/#exercises","text":"","title":"Exercises"},{"location":"dotnet_core/SQLSVR_WEBAPI/dotnet-2.1.x/03-exercises/#exercise_1","text":"The api is not complete, in the demo we looked at the player API, but we still have models for the following tables: GameSchedule PoolPoints Staff Teams Your task is to complete the api so data can be submitted using PostMan.","title":"Exercise 1"},{"location":"php/container_setup/install/","text":"Setup new container IF YOU ARE USING DOCKER-TOOLBOX FOR WINDOWS For Docker Toolbox for Windows to be able to share it's files with the host machine to the container, the container MUST be placed inside the C:\\Users\\** folder. So create a folder called docker inside C:\\Users\\ your username \\ otherwise you cannot make this work. To create the docker folder do this: type in cd /c/users/ username / create the docker folder mkdir docker go into the folder cd docker Once you have done this once, in the future you can simply go to the folder by typing in: cd /c/users/ username /docker important Stop any current containers you have going this will free up the ports that are in use: docker stop $( docker ps -a ) This won't delete them, but it will free up the ports that are used by any containers. Navigate to your code folder where you want to store you project, this could be your desktop or a designated folder. cd ~/Desktop // **REMEMBER IF YOU ARE USING DOCKER TOOLBOX FOR WINDOWS** cd /c/Users/ username /docker Set a ENV Variable temporary for the folder name FOLDER= VALUE where = the name you want your project to be Note ENV Variables, will loose their value when you close the terminal window. There is a way to recreate them, but since we don't want to have this variable permanently setup we won't do that here. Every time you want to reference our project, we can just use $FOLDER instead of the actual name. Download the docker-compose file curl -LOk https://github.com/to-jk11/php-container-kit/archive/master.zip unzip master.zip rm -f master.zip mv php-container-kit-master $FOLDER mkdir -p $FOLDER /www Go into the VALUE folder: cd $FOLDER Inside the folder there is a docker-compose.yml file. Run the docker-compose command to get your containers up and running: docker-compose up -d The www folder serves as the root folder of your website. So that is where you put your code files. You can now open the www in your favourite code editor. (for example code www ) Next you will need to install composer which you can do here: Download for windows Composer for Windows Download for Mac Copy each of these lines into your terminal php -r copy( https://getcomposer.org/installer , composer-setup.php ); php -r if (hash_file( sha384 , composer-setup.php ) === 48e3236262b34d30969dca3c37281b3b4bbe3221bda826ac6a9a62d6444cdb0dcd0615698a5cbe587c3f0fe57a54d8f5 ) { echo Installer verified ; } else { echo Installer corrupt ; unlink( composer-setup.php ); } echo PHP_EOL; php composer-setup.php php -r unlink( composer-setup.php ); Note The container has been setup with the apache2 rewrite module enabled. This will be important when we start using MVC.","title":"Setup new container"},{"location":"php/container_setup/install/#setup_new_container","text":"IF YOU ARE USING DOCKER-TOOLBOX FOR WINDOWS For Docker Toolbox for Windows to be able to share it's files with the host machine to the container, the container MUST be placed inside the C:\\Users\\** folder. So create a folder called docker inside C:\\Users\\ your username \\ otherwise you cannot make this work. To create the docker folder do this: type in cd /c/users/ username / create the docker folder mkdir docker go into the folder cd docker Once you have done this once, in the future you can simply go to the folder by typing in: cd /c/users/ username /docker important Stop any current containers you have going this will free up the ports that are in use: docker stop $( docker ps -a ) This won't delete them, but it will free up the ports that are used by any containers. Navigate to your code folder where you want to store you project, this could be your desktop or a designated folder. cd ~/Desktop // **REMEMBER IF YOU ARE USING DOCKER TOOLBOX FOR WINDOWS** cd /c/Users/ username /docker Set a ENV Variable temporary for the folder name FOLDER= VALUE where = the name you want your project to be Note ENV Variables, will loose their value when you close the terminal window. There is a way to recreate them, but since we don't want to have this variable permanently setup we won't do that here. Every time you want to reference our project, we can just use $FOLDER instead of the actual name. Download the docker-compose file curl -LOk https://github.com/to-jk11/php-container-kit/archive/master.zip unzip master.zip rm -f master.zip mv php-container-kit-master $FOLDER mkdir -p $FOLDER /www Go into the VALUE folder: cd $FOLDER Inside the folder there is a docker-compose.yml file. Run the docker-compose command to get your containers up and running: docker-compose up -d The www folder serves as the root folder of your website. So that is where you put your code files. You can now open the www in your favourite code editor. (for example code www ) Next you will need to install composer which you can do here: Download for windows Composer for Windows Download for Mac Copy each of these lines into your terminal php -r copy( https://getcomposer.org/installer , composer-setup.php ); php -r if (hash_file( sha384 , composer-setup.php ) === 48e3236262b34d30969dca3c37281b3b4bbe3221bda826ac6a9a62d6444cdb0dcd0615698a5cbe587c3f0fe57a54d8f5 ) { echo Installer verified ; } else { echo Installer corrupt ; unlink( composer-setup.php ); } echo PHP_EOL; php composer-setup.php php -r unlink( composer-setup.php ); Note The container has been setup with the apache2 rewrite module enabled. This will be important when we start using MVC.","title":"Setup new container"},{"location":"php/mvc_framework/how-it-works/","text":"How to setup MVC Using this framework, setting up MVC is a pretty easy process. Let's have a look at the folder structure: The main folders to focus on are: Foldername Purpose app backend files (all the php stuff) public frontend files (css, images, javascript etc) We will get to both of those later on Foldername Purpose rest Used to do some api testing, we can ignore this for now. sql Used as a place where you can save your mysql files. The file (part1.sql) that is in there is used for the demo projects. The files in the root folder are used as follows: Filename Purpose .env This is used to read your DB credentials and other info that needs to be secure .gitignore Ignore all the setup files that can be run remotely .htaccess There to route all the controller paths composer.json Install php composer packages, we only use this for env files for now env.example an example for when the .env file is ignored, which it should be readme.md default readme file Public Folder In the public folder we have 2 files at the base: .htaccess - used for routing of url paths index.php - used as a base, but not edited The index.php contains very little php: ?php include ( ../app/bootstrap.php ); $init = new Core (); ? Core is a class which is defined in the app/libraries folder. bootstrap.php is a file that sets up a number of php files we want to import, but we don't want to expose the paths of those files to the public. The other folders are just placeholders for any assets that are needed in the project. To link to any of those files we do need to use some special (sort of) php syntax, but we will get to that later. App Folder The app folder is where all the magic happens. It is also the folder we hide from the public, because all our server side code is there. Let's go through the folder / file structure Here you will see bootstrap.php . If you have a look at that file, you will just see that it imports a bunch of other files. The helper folder contains some helper files, we will reference to them later. The libraries folder contains the foundtion of the framework so look, but don't touch The models , views and controllers folder carry the respective files to make up the different webpages. Which we talk about in the next section.","title":"How it works"},{"location":"php/mvc_framework/how-it-works/#how_to_setup_mvc","text":"Using this framework, setting up MVC is a pretty easy process. Let's have a look at the folder structure: The main folders to focus on are: Foldername Purpose app backend files (all the php stuff) public frontend files (css, images, javascript etc) We will get to both of those later on Foldername Purpose rest Used to do some api testing, we can ignore this for now. sql Used as a place where you can save your mysql files. The file (part1.sql) that is in there is used for the demo projects. The files in the root folder are used as follows: Filename Purpose .env This is used to read your DB credentials and other info that needs to be secure .gitignore Ignore all the setup files that can be run remotely .htaccess There to route all the controller paths composer.json Install php composer packages, we only use this for env files for now env.example an example for when the .env file is ignored, which it should be readme.md default readme file","title":"How to setup MVC"},{"location":"php/mvc_framework/how-it-works/#public_folder","text":"In the public folder we have 2 files at the base: .htaccess - used for routing of url paths index.php - used as a base, but not edited The index.php contains very little php: ?php include ( ../app/bootstrap.php ); $init = new Core (); ? Core is a class which is defined in the app/libraries folder. bootstrap.php is a file that sets up a number of php files we want to import, but we don't want to expose the paths of those files to the public. The other folders are just placeholders for any assets that are needed in the project. To link to any of those files we do need to use some special (sort of) php syntax, but we will get to that later.","title":"Public Folder"},{"location":"php/mvc_framework/how-it-works/#app_folder","text":"The app folder is where all the magic happens. It is also the folder we hide from the public, because all our server side code is there. Let's go through the folder / file structure Here you will see bootstrap.php . If you have a look at that file, you will just see that it imports a bunch of other files. The helper folder contains some helper files, we will reference to them later. The libraries folder contains the foundtion of the framework so look, but don't touch The models , views and controllers folder carry the respective files to make up the different webpages. Which we talk about in the next section.","title":"App Folder"},{"location":"php/mvc_framework/mvc/","text":"APP : Models - Views - Controllers To know what we are working with, let's define what each of these files do. As you can see in the image above, the user uses the a website, by navigating to it. Once they are on that website, the different pieces come together. The Controller is in a way the glue to the process and so a couple of things need to be remembered. The controller communicates to the model The controller communicates to the view The model NEVER communicates to the view. Whatever data the model has, is send to the controller Whatever view there is to display the data is selected by the controller. So by those rules that are shown above, the starting point for any page would be the controller. THE URL Format When you look at a url for a website you will see the following format: The default controller for this framework is called Pages The default for index for this framework is called Index There is no default value for the parameter, since it only applies when you need a specific record for something. Now there are 2 ways you can set this up: You either create a tonne of controllers and give them each a single action or - and this is the way we will do it - you create a single controller for each function and give them each the appropriate methods in relation to the CRUD acronym. So each Controller will get at least a single actions with a maximum or 5 actions. The Controller The format of a controller looks something like this to begin with: A basic controller ?php include(APPROOT . /helper/helperfunctions.php ); class Pages extends Controller { public function __construct() { $this- people = $this- model( People ); } public function index() { // Links to model $people = $this- people- getAllPeople(); $title = $this- people- title(); $data = []; // Send data to View $this- view( pages/index , $data = []); } } ? These are not auto-generated, but you can just copy this code and modify it to what you need. Let's break it up into parts: Import the helper functions Import the helper functions so you can manipulate the URL include(APPROOT . /helper/helperfunctions.php ); Create the contoller class Create the class - this name has to be unique within your project and the file in which it is created must have the same name. The extends keyword means we are inheriting from the Controller class All the other content goes inside of it. class Pages extends Controller { ... } The constructor - setting the model In the class constructor we set the name of the model(s) we need to interact with. If you don't need a model, because your data is static - then you can omit this. You can also specify multiple models inside of the one controller, but we will look at that later on. The name of the model MUST BE the same name as the model file name as it looks for the file name. The Action The actions are part of the URL and since index is the default action, it will be needed for setting up controller only URLs. In the first part we setup all the data we need to get from our model(s), this are basically functions that request data from the database and save the result (an array) into a variable. These variables can hold anything - it doesn't have to be a function. The first part of the view() method is the link to the folder inside of the views folder and then the filename. The file name is the name of actual file in the views folder and has nothing to do with the name of the endpoint. The files may also be called template1, template2 etc. public function index() { // Links to model $people = $this- people- getAllPeople(); $title = $this- people- title(); $data = []; // Send data to View $this- view( pages/index , $data = []); } The $data array (which must be included) is used to pass in all the variables you create to the view, so you may end up with something like $this- view( pages/index , $data = [$people, $title]); or just an empty array, which is passed down by default. The Model In the models folder, we have all our models. A model is the part that queries, sends and receives the data from the database. A model is usually closely associated with a controller, as far as the name goes, but: It cannot be the same name - using an underscore in the name is enough. It should be descriptive of what you type of data you want, so it is easier to get to later. The format of a model looks something like this to begin with: A basic model class People { private $db; public function __construct() { $this- db = new Database; } public function title() { return Show All People ; } public function getAllPeople() { $this- db- query( SELECT * FROM tbl_people ); return $this- db- resultSet(); } } Again these are not auto-generated, but you can just copy this code and modify it to what you need. Let's break it up into parts: The model class The class contains all of the methods - it doesn't inherit from anyting. class People { ... } Link to Database The model is the part that communicates to the database, so it needs to setup a new instance of the object. The queries Below you will see 2 queries, one returns a string and the second one does a query to a database. public function title() { return Show All People ; } public function getAllPeople() { $this- db- query( SELECT * FROM tbl_people ); return $this- db- resultSet(); } Query with a parameter Queries can be as complex as you require them to be, but and any parameters are binded into the query. They are not directly hard coded into it. For each paramter for a query query, you need to pass in the parameter as a php variable, since you do not know what the value will be at development time. Since we don't know the value, we need to sanitize these variables and we that with the bind() function. As you can see the parameter in the query is identified with a : and in the binding function it is mapped to the variable name. When doing a Select query, we then return the result as per normal, which gives an array - even if the array only has a single item in it. public function getSinglePerson($id) { $this- db- query( SELECT * FROM tbl_people WHERE ID = :id ); $this- db- bind( :id , $id); return $this- db- resultSet(); } INSERT / UPDATE / DELETE with a parameter For the C UD and type queries, we need to pass in paramters as and they work exactly the same public function addPerson($fn, $ln, $dob) { $this- db- query( INSERT INTO tbl_people (FNAME, LNAME, DOB) VALUES (:fn, :ln, :dob) ); $this- db- bind( :fn , $fn); $this- db- bind( :ln , $ln); $this- db- bind( :dob , $dob); if($this- db- execute()) { return true; } else { return false; } } As you can see we pass in 3 parameters and sanitize each of them. At the end, we check if the database was successfully changed by returning a simple true / false boolean. The View In the views folder we have all the templates. Now each of the view templates can be used multiple times and have a different way of processing the data coming in. TIP = Example You may have a single template that has 2 columns, but how the data comes into those columns is different, therefore you need multiple versions of that one template. HINT = Use the controllers as folders To make it easier to find the templates to use for each controller, create a folder that has the name of the controller and put the template files that are needed for each controller in there. You will need to the path to the view file in the controller: $this- view( folder_name/view_template , $data = []); The view file, although it ends with a .php extension, most of it is HTML. The format of a model looks something like this to begin with: Format of View ?php include(APPROOT . /views/includes/header.php ); ? div class= row /div ?php include(APPROOT . /views/includes/footer.php ); ? The class=\"row\" is a reference to using bootstrap, but it could be anything. You will notice there are 2 files, a header.php and a footer.php file. I tend to put them in the a folder called includes which you can see from the path that is used. In the header.php file we include everything from the top html tag to the where the commonality of each page ends. So a header for a page could look like this: The footer.php file includes everything from where the first tag of a view ends and the common footer for each page starts. So a footer for a page could look like this","title":"Mvc"},{"location":"php/mvc_framework/mvc/#app_models_-_views_-_controllers","text":"To know what we are working with, let's define what each of these files do. As you can see in the image above, the user uses the a website, by navigating to it. Once they are on that website, the different pieces come together. The Controller is in a way the glue to the process and so a couple of things need to be remembered. The controller communicates to the model The controller communicates to the view The model NEVER communicates to the view. Whatever data the model has, is send to the controller Whatever view there is to display the data is selected by the controller. So by those rules that are shown above, the starting point for any page would be the controller.","title":"APP : Models - Views - Controllers"},{"location":"php/mvc_framework/mvc/#the_url_format","text":"When you look at a url for a website you will see the following format: The default controller for this framework is called Pages The default for index for this framework is called Index There is no default value for the parameter, since it only applies when you need a specific record for something. Now there are 2 ways you can set this up: You either create a tonne of controllers and give them each a single action or - and this is the way we will do it - you create a single controller for each function and give them each the appropriate methods in relation to the CRUD acronym. So each Controller will get at least a single actions with a maximum or 5 actions.","title":"THE URL Format"},{"location":"php/mvc_framework/mvc/#the_controller","text":"The format of a controller looks something like this to begin with: A basic controller ?php include(APPROOT . /helper/helperfunctions.php ); class Pages extends Controller { public function __construct() { $this- people = $this- model( People ); } public function index() { // Links to model $people = $this- people- getAllPeople(); $title = $this- people- title(); $data = []; // Send data to View $this- view( pages/index , $data = []); } } ? These are not auto-generated, but you can just copy this code and modify it to what you need. Let's break it up into parts: Import the helper functions Import the helper functions so you can manipulate the URL include(APPROOT . /helper/helperfunctions.php ); Create the contoller class Create the class - this name has to be unique within your project and the file in which it is created must have the same name. The extends keyword means we are inheriting from the Controller class All the other content goes inside of it. class Pages extends Controller { ... } The constructor - setting the model In the class constructor we set the name of the model(s) we need to interact with. If you don't need a model, because your data is static - then you can omit this. You can also specify multiple models inside of the one controller, but we will look at that later on. The name of the model MUST BE the same name as the model file name as it looks for the file name. The Action The actions are part of the URL and since index is the default action, it will be needed for setting up controller only URLs. In the first part we setup all the data we need to get from our model(s), this are basically functions that request data from the database and save the result (an array) into a variable. These variables can hold anything - it doesn't have to be a function. The first part of the view() method is the link to the folder inside of the views folder and then the filename. The file name is the name of actual file in the views folder and has nothing to do with the name of the endpoint. The files may also be called template1, template2 etc. public function index() { // Links to model $people = $this- people- getAllPeople(); $title = $this- people- title(); $data = []; // Send data to View $this- view( pages/index , $data = []); } The $data array (which must be included) is used to pass in all the variables you create to the view, so you may end up with something like $this- view( pages/index , $data = [$people, $title]); or just an empty array, which is passed down by default.","title":"The Controller"},{"location":"php/mvc_framework/mvc/#the_model","text":"In the models folder, we have all our models. A model is the part that queries, sends and receives the data from the database. A model is usually closely associated with a controller, as far as the name goes, but: It cannot be the same name - using an underscore in the name is enough. It should be descriptive of what you type of data you want, so it is easier to get to later. The format of a model looks something like this to begin with: A basic model class People { private $db; public function __construct() { $this- db = new Database; } public function title() { return Show All People ; } public function getAllPeople() { $this- db- query( SELECT * FROM tbl_people ); return $this- db- resultSet(); } } Again these are not auto-generated, but you can just copy this code and modify it to what you need. Let's break it up into parts: The model class The class contains all of the methods - it doesn't inherit from anyting. class People { ... } Link to Database The model is the part that communicates to the database, so it needs to setup a new instance of the object. The queries Below you will see 2 queries, one returns a string and the second one does a query to a database. public function title() { return Show All People ; } public function getAllPeople() { $this- db- query( SELECT * FROM tbl_people ); return $this- db- resultSet(); } Query with a parameter Queries can be as complex as you require them to be, but and any parameters are binded into the query. They are not directly hard coded into it. For each paramter for a query query, you need to pass in the parameter as a php variable, since you do not know what the value will be at development time. Since we don't know the value, we need to sanitize these variables and we that with the bind() function. As you can see the parameter in the query is identified with a : and in the binding function it is mapped to the variable name. When doing a Select query, we then return the result as per normal, which gives an array - even if the array only has a single item in it. public function getSinglePerson($id) { $this- db- query( SELECT * FROM tbl_people WHERE ID = :id ); $this- db- bind( :id , $id); return $this- db- resultSet(); } INSERT / UPDATE / DELETE with a parameter For the C UD and type queries, we need to pass in paramters as and they work exactly the same public function addPerson($fn, $ln, $dob) { $this- db- query( INSERT INTO tbl_people (FNAME, LNAME, DOB) VALUES (:fn, :ln, :dob) ); $this- db- bind( :fn , $fn); $this- db- bind( :ln , $ln); $this- db- bind( :dob , $dob); if($this- db- execute()) { return true; } else { return false; } } As you can see we pass in 3 parameters and sanitize each of them. At the end, we check if the database was successfully changed by returning a simple true / false boolean.","title":"The Model"},{"location":"php/mvc_framework/mvc/#the_view","text":"In the views folder we have all the templates. Now each of the view templates can be used multiple times and have a different way of processing the data coming in. TIP = Example You may have a single template that has 2 columns, but how the data comes into those columns is different, therefore you need multiple versions of that one template. HINT = Use the controllers as folders To make it easier to find the templates to use for each controller, create a folder that has the name of the controller and put the template files that are needed for each controller in there. You will need to the path to the view file in the controller: $this- view( folder_name/view_template , $data = []); The view file, although it ends with a .php extension, most of it is HTML. The format of a model looks something like this to begin with: Format of View ?php include(APPROOT . /views/includes/header.php ); ? div class= row /div ?php include(APPROOT . /views/includes/footer.php ); ? The class=\"row\" is a reference to using bootstrap, but it could be anything. You will notice there are 2 files, a header.php and a footer.php file. I tend to put them in the a folder called includes which you can see from the path that is used. In the header.php file we include everything from the top html tag to the where the commonality of each page ends. So a header for a page could look like this: The footer.php file includes everything from where the first tag of a view ends and the common footer for each page starts. So a footer for a page could look like this","title":"The View"},{"location":"php/mvc_framework/setup/","text":"Setup MVC Project What you need This repository should be loaded in the www folder if you are using the https://github.com/to-jk11/php-container-kit/ repository Download the following files into the www container Get the MVC Framework curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip unzip master.zip cd php-mvc-kit-master/ find . -maxdepth 1 -exec mv {} .. \\; cd .. rm -rf php-mvc-kit-master rm -rf master.zip A lot happens in the command above, so if you want to know what it does, click on the hint below. If you want to know what happens First we download the repostory that contains all the base code as a zip file curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip Next we unzip the master.zip file, which gives us the php-mvc-kit-master folder cd php-mvc-kit-master Then we move all of the files into the parent folder: `find . -maxdepth 1 -exec mv {} .. \\;` Ignore the message that says: mv: cannot move .' to ../.': Device or resource busy Last we go back to the parent folder and remove the php-mvc-kit-master folder and the master.zip file cd .. rm -rf php-mvc-kit-master rm -rf master.zip Once the framework has been downloaded type in composer update and wait while some plugins are installed. Setup your git repository Setup Git Next you will need to create your git repository so you can save your work: git init Add the remote repository link // If you are using https and have a public repository (uses port 443) git remote add origin https://url-to-your-repo // If you are using https and have a private repository (uses port 443) git remote add origin https://token@username:url-to-your-repo // If you are using ssh (uses port 22) git remote add origin git@github.com:username/reponame The link \"https://url-to-your-repo\" is the link to your github repository Now you can go to http://localhost:8000 (docker for (your OS)) or http://192.168.99.100:8000 (docker toolbox in combination with VirtualBox) and you will see the following screen: Note When using Docker Toolbox for windows, the URL will be http://192.168.99.100:8000","title":"Setup"},{"location":"php/mvc_framework/setup/#setup_mvc_project","text":"What you need This repository should be loaded in the www folder if you are using the https://github.com/to-jk11/php-container-kit/ repository Download the following files into the www container Get the MVC Framework curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip unzip master.zip cd php-mvc-kit-master/ find . -maxdepth 1 -exec mv {} .. \\; cd .. rm -rf php-mvc-kit-master rm -rf master.zip A lot happens in the command above, so if you want to know what it does, click on the hint below. If you want to know what happens First we download the repostory that contains all the base code as a zip file curl -LOk https://github.com/to-jk11/php-mvc-kit/archive/master.zip Next we unzip the master.zip file, which gives us the php-mvc-kit-master folder cd php-mvc-kit-master Then we move all of the files into the parent folder: `find . -maxdepth 1 -exec mv {} .. \\;` Ignore the message that says: mv: cannot move .' to ../.': Device or resource busy Last we go back to the parent folder and remove the php-mvc-kit-master folder and the master.zip file cd .. rm -rf php-mvc-kit-master rm -rf master.zip Once the framework has been downloaded type in composer update and wait while some plugins are installed.","title":"Setup MVC Project"},{"location":"php/mvc_framework/setup/#setup_your_git_repository","text":"Setup Git Next you will need to create your git repository so you can save your work: git init Add the remote repository link // If you are using https and have a public repository (uses port 443) git remote add origin https://url-to-your-repo // If you are using https and have a private repository (uses port 443) git remote add origin https://token@username:url-to-your-repo // If you are using ssh (uses port 22) git remote add origin git@github.com:username/reponame The link \"https://url-to-your-repo\" is the link to your github repository Now you can go to http://localhost:8000 (docker for (your OS)) or http://192.168.99.100:8000 (docker toolbox in combination with VirtualBox) and you will see the following screen: Note When using Docker Toolbox for windows, the URL will be http://192.168.99.100:8000","title":"Setup your git repository"}]}